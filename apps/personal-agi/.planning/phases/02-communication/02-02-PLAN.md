---
phase: 02-communication
plan: 02
type: execute
---

<objective>
Implement TelegramBot class that integrates with PersonalAGI agent.

Purpose: Enable bidirectional Telegram communication with the agent.
Output: Working telegram module with bot class and message handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-communication/02-RESEARCH.md
@.planning/phases/02-communication/02-01-SUMMARY.md

**From research:**
- Use python-telegram-bot v22+ async API
- User whitelist via TELEGRAM_OWNER_ID
- Chunk long responses (4096 char limit)
- Handle message processing without blocking

**Prerequisites from prior plans:**
- python-telegram-bot installed
- TELEGRAM_BOT_TOKEN and TELEGRAM_OWNER_ID in config
- PersonalAGI.process_message() available
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram bot module</name>
  <files>src/telegram/__init__.py, src/telegram/bot.py</files>
  <action>
Create `src/telegram/` directory and files.

**src/telegram/__init__.py:**
```python
"""Telegram bot integration for Personal AGI."""
from src.telegram.bot import TelegramBot

__all__ = ["TelegramBot"]
```

**src/telegram/bot.py:**
```python
"""Telegram bot wrapper for Personal AGI agent."""
import structlog
from telegram import Update
from telegram.constants import MessageLimit
from telegram.ext import Application, CommandHandler, MessageHandler, filters

from src.agent import PersonalAGI
from src.config import TELEGRAM_BOT_TOKEN, TELEGRAM_OWNER_ID

log = structlog.get_logger()


class TelegramBot:
    """Telegram bot that interfaces with PersonalAGI agent."""

    def __init__(self, agent: PersonalAGI):
        self.agent = agent
        self.owner_id = int(TELEGRAM_OWNER_ID) if TELEGRAM_OWNER_ID else None
        self.app = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        self._setup_handlers()

    def _setup_handlers(self):
        """Register message handlers."""
        self.app.add_handler(CommandHandler("start", self._handle_start))
        self.app.add_handler(CommandHandler("status", self._handle_status))
        self.app.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message)
        )

    def _is_authorized(self, user_id: int) -> bool:
        """Check if user is authorized to use the bot."""
        return user_id == self.owner_id

    async def _handle_start(self, update: Update, context) -> None:
        """Handle /start command."""
        user_id = update.effective_user.id
        if not self._is_authorized(user_id):
            log.warning("unauthorized_start", user_id=user_id)
            await update.message.reply_text("Unauthorized.")
            return

        log.info("bot_started", user_id=user_id)
        await update.message.reply_text(
            "Personal AGI ready. Send me a message or task!"
        )

    async def _handle_status(self, update: Update, context) -> None:
        """Handle /status command."""
        if not self._is_authorized(update.effective_user.id):
            await update.message.reply_text("Unauthorized.")
            return

        status = "running" if self.agent.running else "stopped"
        await update.message.reply_text(f"Agent status: {status}")

    async def _handle_message(self, update: Update, context) -> None:
        """Handle incoming text messages."""
        user_id = update.effective_user.id
        if not self._is_authorized(user_id):
            log.warning("unauthorized_message", user_id=user_id)
            return  # Silent ignore for non-owners

        message_text = update.message.text
        log.info("received_message", user_id=user_id, preview=message_text[:50])

        # Send typing indicator while processing
        await update.message.chat.send_action("typing")

        try:
            response = await self.agent.process_message(message_text)
            await self._send_response(update, response)
        except Exception as e:
            log.error("message_error", error=str(e))
            await update.message.reply_text(f"Error: {e}")

    async def _send_response(self, update: Update, text: str) -> None:
        """Send response, chunking if necessary."""
        max_len = MessageLimit.MAX_TEXT_LENGTH

        if len(text) <= max_len:
            await update.message.reply_text(text)
            return

        # Chunk long responses
        for i in range(0, len(text), max_len):
            chunk = text[i:i + max_len]
            await update.message.reply_text(chunk)

    async def send_notification(self, message: str) -> None:
        """Send proactive notification to owner."""
        if self.owner_id:
            await self.app.bot.send_message(
                chat_id=self.owner_id,
                text=message
            )

    async def start(self) -> None:
        """Initialize and start the bot."""
        await self.app.initialize()
        await self.app.start()
        await self.app.updater.start_polling()
        log.info("telegram_bot_started")

    async def stop(self) -> None:
        """Stop the bot gracefully."""
        await self.app.updater.stop()
        await self.app.stop()
        await self.app.shutdown()
        log.info("telegram_bot_stopped")
```

**Key patterns:**
- User whitelist via owner_id check
- Typing indicator while agent processes
- Response chunking for long messages
- Structured logging throughout
- Graceful start/stop lifecycle
  </action>
  <verify>
- `ls src/telegram/` shows __init__.py and bot.py
- `python -c "from src.telegram import TelegramBot; print('OK')"` works
  </verify>
  <done>TelegramBot class created with message handling and authorization</done>
</task>

<task type="auto">
  <name>Task 2: Integrate TelegramBot with AgentRunner</name>
  <files>src/main.py</files>
  <action>
Update `src/main.py` to integrate TelegramBot alongside the existing AgentRunner.

The updated main.py should:
1. Import TelegramBot and validate_telegram_config
2. Add telegram_bot to AgentRunner
3. Start bot in both interactive and daemon modes
4. Handle graceful shutdown of bot

**Key changes to AgentRunner:**

```python
class AgentRunner:
    """Manages agent lifecycle with graceful shutdown."""

    def __init__(self, use_telegram: bool = True):
        self.agent = PersonalAGI()
        self.telegram_bot = None
        self.use_telegram = use_telegram
        self.shutdown_event = asyncio.Event()

        if use_telegram:
            from src.telegram import TelegramBot
            self.telegram_bot = TelegramBot(self.agent)
```

**Key changes to run methods:**

In both run_interactive() and run_daemon():
- Start telegram_bot after agent.start()
- Stop telegram_bot before agent.stop()

**Key changes to main():**

```python
async def main():
    load_dotenv()

    # Validate base configuration
    if not validate_config():
        log.error("config_validation_failed")
        sys.exit(1)

    # Check if Telegram is configured
    use_telegram = validate_telegram_config()
    if not use_telegram:
        log.warning("telegram_not_configured", hint="Running without Telegram")

    runner = AgentRunner(use_telegram=use_telegram)
    # ... rest of main
```

This allows running without Telegram if not configured (backwards compatible).

Do NOT break existing interactive mode functionality.
Do NOT remove signal handling.
  </action>
  <verify>
- `python -c "from src.main import main; print('OK')"` works
- Signal handling still present in code
- TelegramBot integration present in AgentRunner
  </verify>
  <done>main.py updated to integrate TelegramBot with AgentRunner lifecycle</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] src/telegram/__init__.py exists
- [ ] src/telegram/bot.py has TelegramBot class
- [ ] TelegramBot has authorization check
- [ ] TelegramBot handles message chunking
- [ ] main.py integrates TelegramBot
- [ ] All imports work without errors
</verification>

<success_criteria>
- TelegramBot class fully implemented
- AgentRunner integrates with TelegramBot
- Authorization enforced via owner_id
- Backwards compatible (works without Telegram config)
- Ready for end-to-end testing
</success_criteria>

<output>
After completion, create `.planning/phases/02-communication/02-02-SUMMARY.md` with:
- TelegramBot implementation details
- Integration approach
- Ready for verification testing
</output>

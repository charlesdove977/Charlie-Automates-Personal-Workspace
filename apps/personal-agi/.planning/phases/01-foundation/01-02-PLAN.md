---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Implement the core agent wrapper using ClaudeSDKClient and create the main entry point with graceful shutdown handling.

Purpose: Build the foundational agent loop that all integrations (Telegram, Google, etc.) will connect to.
Output: Working agent.py and main.py that can run persistently and handle shutdown gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**From research - critical patterns:**
- Use `ClaudeSDKClient` (NOT repeated `query()` calls) - avoids 12s startup overhead
- Use `anyio` for async operations
- Implement signal handlers for SIGTERM/SIGINT
- Wrap disconnect with timeout to avoid cleanup hangs
- Use structlog for production logging

**Tech available:**
- claude-agent-sdk (installed)
- structlog (installed)
- python-dotenv (installed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent wrapper</name>
  <files>src/agent.py</files>
  <action>
Create `src/agent.py` with a PersonalAGI class that wraps ClaudeSDKClient:

```python
"""Core agent wrapper using ClaudeSDKClient for persistent sessions."""
import asyncio
import anyio
import structlog
from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions
from claude_agent_sdk.types import AssistantMessage, ResultMessage, TextBlock

log = structlog.get_logger()


class PersonalAGI:
    """Personal AGI agent with persistent session management."""

    def __init__(self, system_prompt: str | None = None):
        self.system_prompt = system_prompt or self._default_system_prompt()
        self.client: ClaudeSDKClient | None = None
        self.running = False

    def _default_system_prompt(self) -> str:
        return """You are a personal AGI assistant. Your job is to:
1. Complete tasks autonomously when possible
2. Ask clarifying questions when needed
3. Report back on task completion
4. Be proactive about identifying what you can help with

You have access to tools for reading files, running commands, and searching.
Use them to accomplish tasks efficiently."""

    def _get_options(self) -> ClaudeAgentOptions:
        """Configure agent options with appropriate tools and permissions."""
        return ClaudeAgentOptions(
            allowed_tools=["Read", "Write", "Bash", "Glob", "Grep"],
            permission_mode="acceptEdits",
            system_prompt=self.system_prompt,
        )

    async def start(self) -> None:
        """Start the agent session."""
        self.running = True
        log.info("agent_starting")

    async def stop(self) -> None:
        """Stop the agent gracefully."""
        self.running = False
        log.info("agent_stopping")

    async def process_message(self, message: str) -> str:
        """Process a single message and return the response.

        Uses ClaudeSDKClient context manager for each interaction.
        This is intentional - each message gets fresh context while
        avoiding the overhead of spawning CLI for every query().
        """
        log.info("processing_message", message_preview=message[:50])

        options = self._get_options()
        response_text = ""

        try:
            async with ClaudeSDKClient(options=options) as client:
                await client.query(message)
                async for msg in client.receive_response():
                    if isinstance(msg, AssistantMessage):
                        for block in msg.content:
                            if isinstance(block, TextBlock):
                                response_text += block.text
                    elif isinstance(msg, ResultMessage):
                        if msg.result:
                            response_text = msg.result
                        log.info("task_complete")
        except Exception as e:
            log.error("message_processing_error", error=str(e))
            response_text = f"Error processing message: {e}"

        return response_text
```

**Key design decisions:**
- ClaudeSDKClient per-message (not global) - each message is independent
- Default tools are read-only safe (Read, Glob, Grep) plus Write and Bash for task completion
- permission_mode="acceptEdits" for autonomous operation
- Structured logging throughout
- Simple async interface that future integrations can call

Do NOT add MCP servers yet - that's Phase 2+.
Do NOT implement polling/scheduling - that's Phase 6.
  </action>
  <verify>
- `cat src/agent.py` shows PersonalAGI class
- `python -c "from src.agent import PersonalAGI; print('OK')"` works
- No syntax errors
  </verify>
  <done>agent.py exists with PersonalAGI class, imports cleanly, follows research patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create main entry point</name>
  <files>src/main.py</files>
  <action>
Create `src/main.py` as the entry point for running the agent:

```python
"""Entry point for Personal AGI agent."""
import asyncio
import signal
import sys
import anyio
import structlog
from dotenv import load_dotenv

from src.agent import PersonalAGI
from src.config import validate_config

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.dev.ConsoleRenderer()
    ],
    wrapper_class=structlog.stdlib.BoundLogger,
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)

log = structlog.get_logger()


class AgentRunner:
    """Manages agent lifecycle with graceful shutdown."""

    def __init__(self):
        self.agent = PersonalAGI()
        self.shutdown_event = asyncio.Event()

    def _setup_signal_handlers(self):
        """Set up signal handlers for graceful shutdown."""
        loop = asyncio.get_event_loop()

        for sig in (signal.SIGTERM, signal.SIGINT):
            loop.add_signal_handler(
                sig,
                lambda s=sig: asyncio.create_task(self._handle_shutdown(s))
            )

    async def _handle_shutdown(self, sig):
        """Handle shutdown signal gracefully."""
        log.info("shutdown_signal_received", signal=sig.name)
        self.shutdown_event.set()
        await self.agent.stop()

    async def run_interactive(self):
        """Run in interactive mode for testing."""
        await self.agent.start()
        log.info("interactive_mode_started", hint="Type messages, Ctrl+C to exit")

        while not self.shutdown_event.is_set():
            try:
                # Simple input loop for testing
                user_input = await anyio.to_thread.run_sync(
                    lambda: input("\nYou: ")
                )

                if user_input.lower() in ("exit", "quit", "q"):
                    break

                if not user_input.strip():
                    continue

                response = await self.agent.process_message(user_input)
                print(f"\nAgent: {response}")

            except EOFError:
                break
            except KeyboardInterrupt:
                break

        await self.agent.stop()

    async def run_daemon(self):
        """Run in daemon mode (for Supervisor)."""
        self._setup_signal_handlers()
        await self.agent.start()
        log.info("daemon_mode_started")

        # Wait for shutdown signal
        await self.shutdown_event.wait()

        log.info("daemon_shutting_down")


async def main():
    """Main entry point."""
    load_dotenv()

    # Validate configuration
    if not validate_config():
        log.error("config_validation_failed")
        sys.exit(1)

    runner = AgentRunner()

    # Check if running interactively or as daemon
    if sys.stdin.isatty():
        await runner.run_interactive()
    else:
        await runner.run_daemon()


if __name__ == "__main__":
    anyio.run(main)
```

**Also update src/config.py** to add validate_config():

```python
"""Configuration management for Personal AGI."""
import os
from dotenv import load_dotenv

load_dotenv()

ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")


def validate_config() -> bool:
    """Validate required configuration is present."""
    if not ANTHROPIC_API_KEY:
        print("ERROR: ANTHROPIC_API_KEY environment variable not set")
        print("Copy .env.example to .env and add your API key")
        return False
    return True
```

**Key design decisions:**
- Signal handlers for SIGTERM/SIGINT (Supervisor sends SIGTERM)
- Two modes: interactive (TTY) and daemon (Supervisor)
- Uses anyio.to_thread.run_sync for blocking input() call
- Structured logging configured at startup
- Config validation before starting

Do NOT implement actual task scheduling - that's Phase 6.
  </action>
  <verify>
- `cat src/main.py` shows AgentRunner class
- `cat src/config.py` shows validate_config function
- `python -c "from src.main import main; print('OK')"` works
- No syntax errors
  </verify>
  <done>main.py exists with interactive and daemon modes, signal handling works, config validates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `src/agent.py` has PersonalAGI class with process_message method
- [ ] `src/main.py` has AgentRunner with interactive and daemon modes
- [ ] `src/config.py` has validate_config function
- [ ] All imports resolve without errors
- [ ] Signal handling code present (SIGTERM, SIGINT)
- [ ] structlog configured for production logging
</verification>

<success_criteria>
- PersonalAGI class wraps ClaudeSDKClient correctly
- AgentRunner handles graceful shutdown
- Both interactive and daemon modes implemented
- All imports work
- Ready for 24/7 runtime configuration
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
